<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IM SAFE Readiness Check — Flying M</title>
<style>
  :root{
    --bg:#0b0f14;--card:#121821;--ink:#e9eef5;--muted:#a9b7c6;--accent:#4da3ff;
    --good:#13c27a;--warn:#ffb31a;--bad:#ff5b5b;--ink-strong:#ffffff
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);
    font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
  .wrap{max-width:720px;margin:0 auto;padding:20px}
  .card{background:var(--card);border-radius:16px;padding:18px 18px 22px;
    box-shadow:0 10px 30px rgba(0,0,0,.35);margin:14px 0}
  h1{font-size:1.55rem;margin:.2rem 0 .6rem}
  h2{font-size:1.15rem;margin:.2rem 0 .4rem}
  h3{font-size:1rem;margin:.2rem 0 .4rem}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .center{display:flex;justify-content:center;align-items:center;text-align:center}
  .grid{display:grid;gap:10px}
  .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .muted{color:var(--muted)}
  .big{font-size:2.2rem;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,"Courier New",monospace}

  .btn{appearance:none;border:0;border-radius:14px;padding:14px 18px;font-weight:700;
    color:#0b0f14;background:var(--accent);cursor:pointer;min-width:150px;user-select:none}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn-ghost{background:transparent;color:var(--ink);border:2px solid var(--muted)}
  .btn-wide{width:100%}
  .btn.active{transform:translateY(1px) scale(.98);opacity:.85;filter:saturate(120%)}
  .kbd{display:inline-block;padding:.2rem .45rem;border-radius:.4rem;border:1px solid #2a3850;background:#0c121a;font-weight:700}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;background:#0e141c;border:1px solid #223042;color:var(--muted);font-size:.9rem}
  .hr{height:1px;background:#213043;margin:12px 0}
  .tag{display:inline-block;padding:4px 8px;border-radius:8px;background:#0f1622;color:var(--muted);border:1px solid #223042;font-size:.85rem}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #223042;background:#101826}

  .tapTarget{width:200px;height:200px;border-radius:999px;background:#3a485c;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:1.1rem;user-select:none}
  .tapTarget.ready{background:#6a7688}
  .tapTarget.go{background:#3aa657}

  .bar{height:10px;border-radius:999px;background:#1a2330;overflow:hidden}
  .bar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#4da3ff,#13c27a)}

  .scoreLight{display:flex;gap:8px;align-items:center}
  .dot{width:12px;height:12px;border-radius:999px;background:var(--muted)}
  .dot.green{background:var(--good)} .dot.amber{background:var(--warn)} .dot.red{background:var(--bad)}

  .wordBox{font-weight:900;font-size:2.4rem;letter-spacing:.02em;padding:.2rem .6rem;border-radius:.5rem;background:#0e1520}
  .hide{display:none}

  /* Bigger hit areas for comfort */
  #btnMatch,#btnMismatch{min-width:160px}
  #btnTarget{min-width:240px}
</style>
</head>
<body>
<div class="wrap">
  <header class="card">
    <h1>IM SAFE Readiness Check</h1>
    <div class="muted">A ~90-second, baseline-referenced snapshot of cognitive speed, attention control, and working memory. <span class="tag">Local &amp; private</span></div>
    <div class="hr"></div>
    <div class="grid grid-2">
      <div>
        <h2>How it works</h2>
        <ul class="muted" style="margin:.4rem 0 0;padding-left:1.2rem">
          <li>Reaction (20s) • Color-Word (30s) • 1-back (30s)</li>
          <li>Compare today vs. your personal baseline</li>
          <li>Result: <b>Fit</b> / <b>Caution</b> / <b>No-Go</b> + Readiness %</li>
        </ul>
      </div>
      <div>
        <h2>Baseline days</h2>
        <div class="muted">Rested, sober (≥48h alcohol-free), low stress, well-fed/hydrated. Add multiple baseline sessions for best accuracy.</div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button id="startBtn" class="btn">Start 90-second Check</button>
      <button id="addBaselineBtn" class="btn btn-ghost" disabled>Add This Result to Baseline</button>
      <button id="resetBaselineBtn" class="btn btn-ghost">Manage Baseline</button>
    </div>
    <div class="muted" style="margin-top:6px">Tip: Put your phone in <span class="kbd">Airplane Mode</span> so notifications don’t interrupt timing.</div>
  </header>

  <!-- Test Card -->
  <section id="testCard" class="card hide">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="pill"><span>Step:</span> <b id="stepName">Warm-up</b></div>
      <div class="pill"><span>Time:</span> <b id="countdown">0s</b></div>
    </div>
    <div class="bar" style="margin:10px 0 14px"><i id="progressBar"></i></div>

    <!-- Simple Reaction -->
    <div id="srtPane" class="center" style="min-height:220px">
      <div id="srtTarget" class="tapTarget">WAIT</div>
    </div>

    <!-- Stroop -->
    <div id="stroopPane" class="hide" style="min-height:220px">
      <div class="center" style="margin:10px 0 18px">
        <div id="stroopWord" class="wordBox mono">RED</div>
      </div>
      <div class="row center" style="justify-content:center">
        <button id="btnMatch" class="btn">MATCH</button>
        <button id="btnMismatch" class="btn btn-ghost">MISMATCH</button>
      </div>
      <div class="muted center" style="margin-top:6px">Keyboard: <span class="kbd">F</span> = MATCH, <span class="kbd">J</span> = MISMATCH</div>
    </div>

    <!-- 1-back -->
    <div id="nbackPane" class="hide" style="min-height:220px">
      <div class="center" style="margin:10px 0 18px; min-height:3.2rem">
        <div id="nbackDigit" class="big mono" style="visibility:hidden">5</div>
      </div>
      <div class="center">
        <button id="btnTarget" class="btn">TARGET (Same as previous)</button>
      </div>
      <div class="muted center" style="margin-top:6px">Digit flashes ~250 ms, then blank ~1000 ms. Tap only while the digit is visible. Keyboard: <span class="kbd">Space</span>.</div>
    </div>
  </section>

  <!-- Results -->
  <section id="resultCard" class="card hide">
    <h2>Result</h2>
    <div class="row" style="align-items:center;gap:14px">
      <div class="scoreLight"><span id="lightDot" class="dot"></span><b id="lightLabel">—</b></div>
      <div class="big" id="readinessPct">—%</div>
    </div>
    <div class="muted" id="driverText" style="margin-top:6px"></div>
    <div class="card" style="margin:10px 0;background:#0f1622;border:1px solid #223042">
      <b>Guidance:</b> <span id="guidanceText">—</span>
    </div>
    <div class="grid grid-2">
      <div>
        <h3>Today’s metrics</h3>
        <div class="muted" id="metricToday"></div>
      </div>
      <div>
        <h3>Baseline (mean ± SD)</h3>
        <div class="muted" id="metricBase"></div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button id="againBtn" class="btn">Run Again</button>
      <button id="shareBtn" class="btn btn-ghost">Export Summary</button>
      <button id="addBaselineBtn2" class="btn btn-ghost" disabled>Add This Result to Baseline</button>
    </div>
    <div class="muted" style="margin-top:8px">
      This tool supports—but does not replace—your obligations under 14 CFR 91.17 and the full IM SAFE self-assessment.
    </div>
  </section>

  <!-- Baseline Manager -->
  <section id="baselineCard" class="card hide">
    <h2>Baseline Sessions</h2>
    <div id="baselineList" class="muted">No baseline yet.</div>
    <div class="row" style="margin-top:10px">
      <button id="deleteBaselineBtn" class="btn btn-ghost">Delete All Baseline</button>
      <button id="closeBaselineBtn" class="btn">Close</button>
    </div>
  </section>
</div>

<script>
(function(){
  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const fmt = n => (typeof n === "number" && isFinite(n) ? Math.round(n*10)/10 : n);
  const clamp = (v, lo, hi)=> Math.max(lo, Math.min(hi, v));
  const mean = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;
  const sd = arr => {
    if(arr.length<2) return 0;
    const m=mean(arr); return Math.sqrt(mean(arr.map(x=>(x-m)*(x-m))));
  };
  const now = ()=> performance.now();

  // Cross-platform tap helper with visual press; returns cleanup fn.
  function onTap(el, handler){
    const down = (ev)=>{ ev.preventDefault(); el.classList.add('active'); handler(ev); };
    const up = ()=> el.classList.remove('active');
    el.addEventListener('pointerdown', down, {passive:false});
    el.addEventListener('click', down, {passive:false});
    el.addEventListener('pointerup', up, {passive:true});
    el.addEventListener('pointercancel', up, {passive:true});
    el.addEventListener('mouseleave', up, {passive:true});
    return ()=> {
      el.removeEventListener('pointerdown', down, {passive:false});
      el.removeEventListener('click', down, {passive:false});
      el.removeEventListener('pointerup', up, {passive:true});
      el.removeEventListener('pointercancel', up, {passive:true});
      el.removeEventListener('mouseleave', up, {passive:true});
    };
  }

  const storeKey = "flyingm_imsafe_baseline_v1";
  const loadBaseline = ()=> { try{ return JSON.parse(localStorage.getItem(storeKey)||"[]"); }catch{ return []; } };
  const saveBaseline = (s)=> localStorage.setItem(storeKey, JSON.stringify(s||[]));

  // ---------- DOM refs ----------
  const startBtn = $("#startBtn");
  const addBaselineBtn = $("#addBaselineBtn");
  const addBaselineBtn2 = $("#addBaselineBtn2");
  const resetBaselineBtn = $("#resetBaselineBtn");

  const testCard = $("#testCard");
  const stepName = $("#stepName");
  const countdown = $("#countdown");
  const progressBar = $("#progressBar");

  const srtPane = $("#srtPane"), srtTarget = $("#srtTarget");
  const stroopPane = $("#stroopPane"), stroopWord = $("#stroopWord");
  const btnMatch = $("#btnMatch"), btnMismatch = $("#btnMismatch");
  const nbackPane = $("#nbackPane"), nbackDigit = $("#nbackDigit"), btnTarget = $("#btnTarget");

  const resultCard = $("#resultCard");
  const lightDot = $("#lightDot"), lightLabel=$("#lightLabel"), readinessPct=$("#readinessPct");
  const driverText=$("#driverText"), guidanceText=$("#guidanceText");
  const metricToday=$("#metricToday"), metricBase=$("#metricBase");
  const againBtn=$("#againBtn"), shareBtn=$("#shareBtn");

  const baselineCard=$("#baselineCard"), baselineList=$("#baselineList");
  const deleteBaselineBtn=$("#deleteBaselineBtn"), closeBaselineBtn=$("#closeBaselineBtn");

  let baselineSessions = loadBaseline();
  let sessionResult = null;

  function show(el){ el.classList.remove("hide"); }
  function hide(el){ el.classList.add("hide"); }
  function setProgress(p){ progressBar.style.width = (p*100).toFixed(1)+"%"; }

  // add press feedback to top-level buttons too
  [startBtn, addBaselineBtn, addBaselineBtn2, resetBaselineBtn, againBtn, shareBtn,
   deleteBaselineBtn, closeBaselineBtn, btnMatch, btnMismatch, btnTarget].forEach(b=>{
    if(b) onTap(b, ()=>{ /* no-op handler here; task-specific handlers below */ });
  });

  // ---------- Test Orchestrator ----------
  const DUR = { warmup: 5, srt:20, stroop:30, nback:30 };
  let abortFlag = false;

  async function runTest(){
    abortFlag = false;
    sessionResult = null;
    addBaselineBtn.disabled = true;
    addBaselineBtn2.disabled = true;

    hide(resultCard); hide(baselineCard);
    show(testCard);

    // Warmup
    await sectionTimer("Warm-up", DUR.warmup, (tleft,p)=>{
      countdown.textContent = Math.ceil(tleft)+"s";
      setProgress(p);
      srtTarget.textContent = "WAIT";
      srtTarget.className = "tapTarget ready";
      show(srtPane); hide(stroopPane); hide(nbackPane);
    });

    // SRT
    const srt = await runSRT(DUR.srt);
    if(abortFlag) return;

    // STROOP
    const stro = await runStroop(DUR.stroop);
    if(abortFlag) return;

    // NBACK
    const nb = await runNBack(DUR.nback);
    if(abortFlag) return;

    // Score & show
    sessionResult = computeScoring(srt, stro, nb, baselineSessions);
    renderResults(sessionResult, srt, stro, nb, baselineSessions);
  }

  function sectionTimer(name, seconds, tickFn){
    stepName.textContent = name;
    const t0 = now(), total = seconds*1000;
    return new Promise(res=>{
      function frame(){
        const t = now()-t0;
        if(abortFlag){ return res(); }
        const remaining = Math.max(0, total - t);
        const p = clamp(t/total,0,1);
        tickFn(remaining/1000, p);
        if(t<total){ requestAnimationFrame(frame); } else { res(); }
      }
      requestAnimationFrame(frame);
    });
  }

  // ---------- Simple Reaction Time ----------
  async function runSRT(seconds){
    show(srtPane); hide(stroopPane); hide(nbackPane);
    let rts=[], falseStarts=0, lapses=0;
    let waiting = true, goTime = 0;
    let endAt = now() + seconds*1000;

    function scheduleNext(){
      waiting = true;
      const delay = 800 + Math.random()*1000; // 800–1800 ms
      srtTarget.textContent = "WAIT";
      srtTarget.className = "tapTarget ready";
      setTimeout(()=>{
        if(now()>endAt) return;
        srtTarget.textContent = "TAP";
        srtTarget.className = "tapTarget go";
        waiting=false;
        goTime = now();
      }, delay);
    }

    srtTarget.onclick = ()=>{
      if(now()>endAt) return;
      if(waiting){
        falseStarts++;
      } else {
        const rt = now() - goTime;
        if(rt>1500){ lapses++; }
        else if(rt>=100) rts.push(rt);
        scheduleNext();
      }
    };

    // start first stimulus
    scheduleNext();

    await sectionTimer("Reaction", seconds, (tleft,p)=>{
      countdown.textContent = Math.ceil(tleft)+"s";
      setProgress((DUR.warmup + (DUR.srt - tleft))/ (DUR.warmup + DUR.srt + DUR.stroop + DUR.nback));
    });
    srtTarget.onclick = null;

    const medianRT = rts.length ? rts.slice().sort((a,b)=>a-b)[Math.floor(rts.length/2)] : 999;
    return {medianRT, lapses, falseStarts, n:rts.length};
  }

  // ---------- Stroop (4 colors) ----------
  async function runStroop(seconds){
    show(stroopPane); hide(srtPane); hide(nbackPane);
    const words=["RED","GREEN","BLUE","YELLOW"];
    const colors={RED:"#ff4d4d", GREEN:"#18d96e", BLUE:"#4da3ff", YELLOW:"#ffd633"};

    let trials=[]; let current=null; let tStim=0; let awaiting=true;
    const endAt = now()+seconds*1000;
    // aim ~2 trials/sec
    const isi = 500; // interval between presenting trials; we immediately queue next on response to keep pace

    function newTrial(){
      const word = words[Math.floor(Math.random()*words.length)];
      const colorName = words[Math.floor(Math.random()*words.length)];
      current = {word, colorName, congruent: word===colorName};
      stroopWord.textContent = word;
      stroopWord.style.color = colors[colorName];
      tStim = now(); awaiting=true;
      btnMatch.classList.remove('active'); btnMismatch.classList.remove('active');
    }

    function respond(which){
      if(!awaiting) return;
      awaiting=false;
      const rt = now()-tStim;
      const correct = (current.word===current.colorName && which==="MATCH") ||
                      (current.word!==current.colorName && which==="MISMATCH");
      trials.push({rt, correct, congruent: current.congruent});
      (which==="MATCH"?btnMatch:btnMismatch).classList.add('active');
      setTimeout(()=>{ if(now()<endAt) newTrial(); }, isi);
    }

    const offMatch = onTap(btnMatch, ()=>respond("MATCH"));
    const offMismatch = onTap(btnMismatch, ()=>respond("MISMATCH"));

    // keyboard shortcuts for desktop
    function keyStroop(e){
      const k = e.key.toLowerCase();
      if(k==='f') respond("MATCH");
      if(k==='j') respond("MISMATCH");
    }
    window.addEventListener('keydown', keyStroop);

    newTrial();

    await sectionTimer("Color-Word", seconds, (tleft,p)=>{
      countdown.textContent = Math.ceil(tleft)+"s";
      const progressed = (DUR.warmup + DUR.srt + (DUR.stroop - tleft)) /
                         (DUR.warmup + DUR.srt + DUR.stroop + DUR.nback);
      setProgress(progressed);
    });

    offMatch(); offMismatch();
    window.removeEventListener('keydown', keyStroop);

    const corrects = trials.filter(t=>t.correct);
    const acc = trials.length? (corrects.length / trials.length)*100 : 0;
    const cong = trials.filter(t=>t.congruent && t.correct).map(t=>t.rt);
    const incong = trials.filter(t=>!t.congruent && t.correct).map(t=>t.rt);
    const rtCon = cong.length? mean(cong): NaN;
    const rtIncon = incong.length? mean(incong): NaN;
    const rawCost = (isFinite(rtIncon) && isFinite(rtCon)) ? (rtIncon - rtCon) : NaN;
    const congruencyCost = isFinite(rawCost) ? Math.max(0, rawCost) : NaN; // clamp to >=0
    const meanRTCorrect = corrects.length? mean(corrects.map(t=>t.rt)) : NaN;
    return {acc, meanRTCorrect, congruencyCost, n:trials.length};
  }

  // ---------- 1-back (250ms flash, 1000ms blank) ----------
  async function runNBack(seconds){
    show(nbackPane); hide(srtPane); hide(stroopPane);
    let last=null; let current=null; let tStim=0; let awaiting=false;
    let hits=0, fas=0, miss=0; let hitRTs=[];
    const endAt = now()+seconds*1000;

    const VISIBLE_MS = 250;
    const BLANK_MS = 1000;

    function showDigit(d){
      nbackDigit.textContent = String(d);
      nbackDigit.style.visibility = "visible";
    }
    function hideDigit(){
      nbackDigit.style.visibility = "hidden";
    }

    function nextDigit(){
      let d;
      if(last!==null && Math.random()<0.30){ d = last; } else {
        do{ d = Math.floor(1+Math.random()*9); } while(d===last);
      }
      current = d;
      tStim = now();
      btnTarget.classList.remove('active');
      awaiting=true;
      showDigit(d);
      // hide after 250ms
      setTimeout(()=>{
        // if it was a target and still awaiting at hide time → miss
        if(awaiting && current===last){ miss++; }
        awaiting=false; // cannot respond while blank
        hideDigit();
      }, VISIBLE_MS);
      // schedule next in 1250ms total
      setTimeout(()=>{
        last = current;
        if(now() < endAt){ nextDigit(); }
      }, VISIBLE_MS + BLANK_MS);
    }

    function pressTarget(){
      if(!awaiting) return;
      const rt = now()-tStim;
      if(current===last){
        hits++; if(rt>=100 && rt<=2000) hitRTs.push(rt);
      } else {
        fas++;
      }
      awaiting=false; // single response window
      btnTarget.classList.add('active');
    }

    const offTarget = onTap(btnTarget, pressTarget);

    function keyNback(e){
      if(e.code==='Space'){ e.preventDefault(); pressTarget(); }
    }
    window.addEventListener('keydown', keyNback);

    // start immediately
    nextDigit();

    await sectionTimer("1-back", seconds, (tleft,p)=>{
      countdown.textContent = Math.ceil(tleft)+"s";
      const progressed = (DUR.warmup + DUR.srt + DUR.stroop + (DUR.nback - tleft)) /
                         (DUR.warmup + DUR.srt + DUR.stroop + DUR.nback);
      setProgress(progressed);
    });

    offTarget();
    window.removeEventListener('keydown', keyNback);

    const N = hits + fas + miss;
    const hitRate = (hits / Math.max(1, hits+miss))*100;
    const faRate = (fas / Math.max(1, N - (hits+miss)))*100;
    const dprime = dPrimeApprox(hitRate/100, faRate/100);
    const meanHitRT = hitRTs.length? mean(hitRTs): NaN;
    return {hitRate, faRate, dprime, meanHitRT, counts:{hits, fas, miss}};
  }

  function dPrimeApprox(H, F){
    const eps=1e-4; H=clamp(H,eps,1-eps); F=clamp(F,eps,1-eps);
    function invNorm(p){
      const a=[-39.6968302866538,220.946098424521,-275.928510446969,138.357751867269,-30.6647980661472,2.50662827745924];
      const b=[-54.4760987982241,161.585836858041,-155.698979859887,66.8013118877197,-13.2806815528857];
      const c=[-0.00778489400243029,-0.322396458041136,-2.40075827716184,-2.54973253934373,4.37466414146497,2.93816398269878];
      const d=[0.00778469570904146,0.32246712907004,2.445134137143,3.75440866190742];
      const pl=0.02425, ph=1-pl; let q,r;
      if(p<pl){ q=Math.sqrt(-2*Math.log(p)); return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/
                                                      ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
      if(p>ph){ q=Math.sqrt(-2*Math.log(1-p)); return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/
                                                       ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
      q=p-0.5; r=q*q;
      return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q/
             (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
    }
    return invNorm(H)-invNorm(F);
  }

  // ---------- Scoring ----------
  function computeScoring(srt, stro, nb, baseline){
    const today = {
      srt_median: srt.medianRT, srt_lapses: srt.lapses, srt_false: srt.falseStarts,
      stro_acc: stro.acc, stro_mean_rt: stro.meanRTCorrect, stro_cost: stro.congruencyCost,
      nb_hit: nb.hitRate, nb_fa: nb.faRate, nb_d: nb.dprime, nb_hit_rt: nb.meanHitRT
    };
    const baseStats = computeBaselineStats(baseline);

    function zLowerBetter(key){ const m=baseStats.mean[key], s=baseStats.sd[key];
      if(!isFinite(m) || s===0 || !isFinite(today[key])) return NaN; return (today[key]-m)/s; }
    function zHigherBetter(key){ const m=baseStats.mean[key], s=baseStats.sd[key];
      if(!isFinite(m) || s===0 || !isFinite(today[key])) return NaN; return (m - today[key])/s; }

    const z = {
      speed_median: zLowerBetter("srt_median"),
      speed_lapses: zLowerBetter("srt_lapses"),
      speed_false: zLowerBetter("srt_false"),
      stro_cost: zLowerBetter("stro_cost"),
      stro_acc: zHigherBetter("stro_acc"),
      stro_rt: zLowerBetter("stro_mean_rt"),
      nb_d: zLowerBetter("nb_d"),
      nb_hit_rt: zLowerBetter("nb_hit_rt"),
      nb_fa: zLowerBetter("nb_fa")
    };
    function comp(keys){
      const vals = keys.map(k=>z[k]).filter(Number.isFinite);
      if(!vals.length) return NaN;
      const sorted=vals.slice().sort((a,b)=>a-b);
      const trim=Math.max(0, Math.floor(sorted.length*0.1));
      const trimmed=sorted.slice(trim, sorted.length-trim || undefined);
      return mean(trimmed);
    }
    const zSpeed = comp(["speed_median","speed_lapses","speed_false"]);
    const zStroop = comp(["stro_cost","stro_acc","stro_rt"]);
    const zNback = comp(["nb_d","nb_hit_rt","nb_fa"]);
    const maxZ = Math.max(zSpeed||0, zStroop||0, zNback||0);
    let readiness = 100 - clamp(12 * maxZ, 0, 60);
    readiness = Math.round(readiness);

    let light="amber", label="Caution", guidance="Delay 15–30 minutes, hydrate/snack, then re-test. Consider a safety pilot or deferring non-essential legs.";
    if((maxZ<1.0) && readiness>=85){ light="green"; label="Fit"; guidance="Proceed if all other IM SAFE items are satisfied."; }
    else if(maxZ>=2.0 || readiness<70){ light="red"; label="No-Go"; guidance="Do not act as PIC. Address sleep/stress/alcohol/meds and re-test later."; }

    if(srt.lapses>=2 || (isFinite(stro.acc) && stro.acc<85)){
      light="red"; label="No-Go";
      guidance="Do not act as PIC. Significant attention/alertness degradation detected (excess lapses or low accuracy).";
      readiness = Math.min(readiness, 69);
    }

    const drivers=[];
    if(Number.isFinite(zSpeed) && zSpeed>=1) drivers.push("slower reaction & vigilance");
    if(Number.isFinite(zStroop) && zStroop>=1) drivers.push("reduced attention control");
    if(Number.isFinite(zNback) && zNback>=1) drivers.push("weaker working memory/sustained attention");
    const driver = drivers.length? ("Top driver: " + drivers.join(" + ")) : "Near baseline across domains.";

    return {today, baseStats, z: {speed:zSpeed, stroop:zStroop, nback:zNback, max:maxZ}, readiness, light, label, guidance, driver};
  }

  function computeBaselineStats(baseline){
    const keys = ["srt_median","srt_lapses","srt_false","stro_acc","stro_mean_rt","stro_cost","nb_hit","nb_fa","nb_d","nb_hit_rt"];
    const meanObj={}, sdObj={};
    keys.forEach(k=>{
      const arr = baseline.map(s=>s[k]).filter(x=>Number.isFinite(x));
      meanObj[k] = arr.length? mean(arr): NaN;
      sdObj[k] = arr.length>1? sd(arr): 0;
    });
    return {mean: meanObj, sd: sdObj, n: baseline.length};
  }

  function renderResults(res, srt, stro, nb, baseline){
    hide(testCard); show(resultCard);
    readinessPct.textContent = res.readiness + "%";
    lightDot.className = "dot " + (res.light==="green"?"green":res.light==="red"?"red":"amber");
    lightLabel.textContent = res.label;
    driverText.textContent = res.driver;
    guidanceText.textContent = res.guidance;

    // enable add-to-baseline at >=85% (tweak as desired)
    const canAdd = (res.readiness>=85);
    addBaselineBtn.disabled = !canAdd;
    addBaselineBtn2.disabled = !canAdd;

    metricToday.innerHTML = [
      `Reaction median: <b>${fmt(srt.medianRT)} ms</b>`,
      `Lapses (>1500 ms): <b>${srt.lapses}</b>`,
      `False starts: <b>${srt.falseStarts}</b>`,
      `Stroop accuracy: <b>${fmt(stro.acc)}%</b>`,
      `Stroop mean RT: <b>${fmt(stro.meanRTCorrect)} ms</b>`,
      `Stroop cost: <b>${isFinite(stro.congruencyCost)?fmt(stro.congruencyCost):"—"} ms</b>`,
      `1-back d′: <b>${isFinite(nb.dprime)?fmt(nb.dprime):"—"}</b>`,
      `1-back hit RT: <b>${isFinite(nb.meanHitRT)?fmt(nb.meanHitRT):"—"} ms</b>`,
      `1-back hits / FA / miss: <b>${nb.counts.hits}/${nb.counts.fas}/${nb.counts.miss}</b>`
    ].map(x=>`<div>${x}</div>`).join("");

    const b = res.baseStats;
    function baseLine(label, key, unit=""){
      const m=b.mean[key], s=b.sd[key];
      return `<div>${label}: <b>${isFinite(m)?fmt(m):"—"}${unit}</b> <span class="muted">± ${isFinite(s)?fmt(s):"—"}</span></div>`;
    }
    metricBase.innerHTML = [
      baseLine("Reaction median","srt_median"," ms"),
      baseLine("Lapses","srt_lapses"),
      baseLine("False starts","srt_false"),
      baseLine("Stroop accuracy","stro_acc","%"),
      baseLine("Stroop mean RT","stro_mean_rt"," ms"),
      baseLine("Stroop cost","stro_cost"," ms"),
      baseLine("1-back d′","nb_d",""),
      baseLine("1-back hit RT","nb_hit_rt"," ms"),
    ].join("");

    resultCard.dataset.payload = JSON.stringify(res.today);
  }

  // ---------- Events ----------
  onTap(startBtn, runTest);
  onTap(againBtn, runTest);

  function addCurrentToBaseline(){
    if(!resultCard.dataset.payload) return;
    const today = JSON.parse(resultCard.dataset.payload);
    baselineSessions.push(today);
    saveBaseline(baselineSessions);
    addBaselineBtn.disabled = true;
    addBaselineBtn2.disabled = true;
    alert("Added to baseline. Do this on multiple well-rested, sober days for best accuracy.");
  }
  onTap(addBaselineBtn, addCurrentToBaseline);
  onTap(addBaselineBtn2, addCurrentToBaseline);

  onTap(resetBaselineBtn, ()=>{
    updateBaselineList(); hide(resultCard); hide(testCard); show(baselineCard);
  });
  onTap(closeBaselineBtn, ()=> hide(baselineCard));
  onTap(deleteBaselineBtn, ()=>{
    if(confirm("Delete ALL baseline sessions from this device?")){
      baselineSessions = []; saveBaseline(baselineSessions); updateBaselineList();
    }
  });

  onTap(shareBtn, ()=>{
    const payload = {
      when: new Date().toISOString(),
      today: sessionResult?.today||null,
      baseline_count: baselineSessions.length
    };
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "imsafe-readiness-session.json";
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  function updateBaselineList(){
    const b=baselineSessions;
    if(!b.length){ baselineList.textContent = "No baseline yet."; return; }
    baselineList.innerHTML = b.map((s,i)=>(
      `<div class="chip">#${i+1} • medRT ${fmt(s.srt_median)} ms • lapses ${s.srt_lapses} • Stroop acc ${fmt(s.stro_acc)}% • d′ ${fmt(s.nb_d)}</div>`
    )).join("<br/>");
  }
  updateBaselineList();

  window.addEventListener("beforeunload", (e)=>{
    if(!testCard.classList.contains("hide")){ e.preventDefault(); e.returnValue=""; }
  });
})();
</script>
</body>
</html>
