<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IM SAFE — Two-Minute Drill (Readiness Check)</title>
<style>
  :root{ --bg:#0b0f14;--card:#121821;--ink:#e9eef5;--muted:#a9b7c6;--accent:#4da3ff;--good:#13c27a;--warn:#ffb31a;--bad:#ff5b5b }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
  .wrap{max-width:760px;margin:0 auto;padding:20px}
  .card{background:var(--card);border-radius:16px;padding:18px 18px 22px;box-shadow:0 10px 30px rgba(0,0,0,.35);margin:14px 0}
  h1{font-size:1.55rem;margin:.2rem 0 .6rem}
  h2{font-size:1.15rem;margin:.2rem 0 .4rem}
  h3{font-size:1rem;margin:.2rem 0 .4rem}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .center{display:flex;justify-content:center;align-items:center;text-align:center}
  .grid{display:grid;gap:10px}
  .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .muted{color:var(--muted)}
  .big{font-size:2.2rem;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,"Courier New",monospace}
  .btn{appearance:none;border:0;border-radius:14px;padding:14px 18px;font-weight:700;color:#0b0f14;background:var(--accent);cursor:pointer;min-width:150px;user-select:none}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn-ghost{background:transparent;color:var(--ink);border:2px solid #8795a3}
  .btn.active{transform:translateY(1px) scale(.98);opacity:.85;filter:saturate(120%)}
  .kbd{display:inline-block;padding:.2rem .45rem;border-radius:.4rem;border:1px solid #2a3850;background:#0c121a;font-weight:700}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;background:#0e141c;border:1px solid #223042;color:var(--muted);font-size:.9rem}
  .hr{height:1px;background:#213043;margin:12px 0}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #223042;background:#101826}
  .bar{height:10px;border-radius:999px;background:#1a2330;overflow:hidden}
  .bar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#4da3ff,#13c27a)}
  .tapTarget{width:240px;height:240px;border-radius:999px;background:#3a485c;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:1.1rem;user-select:none;cursor:pointer}
  .tapTarget.ready{background:#6a7688}
  .tapTarget.go{background:#3aa657}
  .wordBox{font-weight:900;font-size:2.6rem;letter-spacing:.02em;padding:.2rem .6rem;border-radius:.5rem;background:#0e1520;min-width:8ch}
  .hide{display:none}
  #btnMatch,#btnMismatch{min-width:160px}
  #btnTarget,#btnNotTarget{min-width:200px}
  .dot{width:12px;height:12px;border-radius:999px;background:var(--muted)}
  .dot.green{background:var(--good)} .dot.amber{background:var(--warn)} .dot.red{background:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <header class="card">
    <h1>IM SAFE — Two-Minute Drill</h1>
    <div class="muted">A 120-second, baseline-referenced snapshot of cognitive speed, attention control, and working memory. <span class="pill">Local &amp; private</span></div>
    <div class="hr"></div>
    <div class="grid grid-2">
      <div>
        <h2>How it works</h2>
        <ul class="muted" style="margin:.4rem 0 0;padding-left:1.2rem">
          <li>Reaction (30s) • Color-Word (45s) • 2-back (5 groups)</li>
          <li>Compare to your baseline (T-scores for Stroop)</li>
          <li>Result: <b>Fit</b> / <b>Caution</b> / <b>No-Go</b> + Readiness %</li>
        </ul>
      </div>
      <div>
        <h2>Baseline days</h2>
        <div class="muted">Rested, sober (≥48h alcohol-free), low stress, well-fed/hydrated. Add ≥3 baseline sessions to enable assessment.</div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button id="startBtn" class="btn">Start Two-Minute Drill</button>
      <button id="addBaselineBtn" class="btn btn-ghost" disabled>Add This Result to Baseline</button>
      <button id="resetBaselineBtn" class="btn btn-ghost">Manage Baseline</button>
      <button id="exportBtn" class="btn btn-ghost">Export PDF</button>
    </div>
    <div class="muted" style="margin-top:6px">Tip: Put your phone in <span class="kbd">Airplane Mode</span> so notifications don’t interrupt timing.</div>
  </header>

  <section id="testCard" class="card hide">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="pill"><span>Step:</span> <b id="stepName">Warm-up</b></div>
      <div class="pill"><span>Time:</span> <b id="countdown">0s</b></div>
    </div>
    <div class="bar" style="margin:10px 0 14px"><i id="progressBar"></i></div>

    <!-- SRT -->
    <div id="srtPane" class="center" style="min-height:260px">
      <div id="srtTarget" class="tapTarget" role="button" aria-label="Tap when it turns green">WAIT</div>
    </div>

    <!-- Stroop -->
    <div id="stroopPane" class="hide" style="min-height:260px">
      <div class="center" style="margin:10px 0 18px">
        <div id="stroopWord" class="wordBox mono" aria-live="off">RED</div>
      </div>
      <div class="row center" style="justify-content:center">
        <button id="btnMatch" class="btn">MATCH</button>
        <button id="btnMismatch" class="btn btn-ghost">MISMATCH</button>
      </div>
      <div class="muted center" style="margin-top:6px">
        Keyboard: <span class="kbd">F</span>=MATCH, <span class="kbd">J</span>=MISMATCH
      </div>
    </div>

    <!-- 2-back -->
    <div id="nbackPane" class="hide" style="min-height:260px">
      <div class="center" style="margin:4px 0 6px;">
        <div class="pill">Session: <b id="groupLabel">Group 1</b> of 5</div>
      </div>
      <div class="center" style="margin:10px 0 18px; min-height:3.2rem">
        <div id="nbackDigit" class="big mono" style="visibility:hidden">5</div>
      </div>
      <div class="center" id="twoBackButtons" style="visibility:hidden">
        <div class="row center" style="justify-content:center">
          <button id="btnTarget" class="btn">TARGET (same as 2 ago)</button>
          <button id="btnNotTarget" class="btn btn-ghost">NOT TARGET</button>
        </div>
      </div>
      <div class="muted center" style="margin-top:6px">Each group: flash 2 digits, then show the 3rd and respond. Keyboard: <span class="kbd">Space</span>=TARGET, <span class="kbd">N</span>=NOT TARGET.</div>
    </div>
  </section>

  <section id="resultCard" class="card hide">
    <h2>Result</h2>
    <div class="row" style="align-items:center;gap:14px">
      <div class="scoreLight"><span id="lightDot" class="dot"></span><b id="lightLabel">—</b></div>
      <div class="big" id="readinessPct">—%</div>
    </div>
    <div class="muted" id="driverText" style="margin-top:6px"></div>
    <div class="card" style="margin:10px 0;background:#0f1622;border:1px solid #223042">
      <b>Guidance:</b> <span id="guidanceText">—</span>
    </div>
    <div class="grid grid-2">
      <div>
        <h3>Today’s metrics</h3>
        <div class="muted" id="metricToday"></div>
      </div>
      <div>
        <h3>Baseline (mean ± SD)</h3>
        <div class="muted" id="metricBase"></div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button id="againBtn" class="btn">Run Again</button>
      <button id="addBaselineBtn2" class="btn btn-ghost" disabled>Add This Result to Baseline</button>
    </div>
    <div class="muted" style="margin-top:8px">
      This tool supports—but does not replace—14 CFR 91.17 and the full IM SAFE self-assessment.
    </div>
  </section>

  <section id="baselineCard" class="card hide">
    <h2>Baseline Sessions</h2>
    <div id="baselineList" class="muted">No baseline yet.</div>
    <div class="row" style="margin-top:10px">
      <button id="deleteBaselineBtn" class="btn btn-ghost">Delete All Baseline</button>
      <button id="closeBaselineBtn" class="btn">Close</button>
    </div>
  </section>
</div>

<script>
(function(){
  const $ = s=>document.querySelector(s);
  const fmt = n=>(typeof n==="number"&&isFinite(n)?Math.round(n*10)/10:n);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const mean=a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:0;
  const sd=a=>{if(a.length<2)return 0;const m=mean(a);return Math.sqrt(mean(a.map(x=>(x-m)*(x-m))));};
  const now=()=>performance.now();

  // Top-level buttons
  function onTap(el, fn){
    const down=e=>{e.preventDefault();el.classList.add('active');fn(e);};
    const up=()=>el.classList.remove('active');
    el.addEventListener('pointerdown',down,{passive:false});
    el.addEventListener('click',down,{passive:false});
    el.addEventListener('pointerup',up,{passive:true});
    el.addEventListener('pointercancel',up,{passive:true});
    el.addEventListener('mouseleave',up,{passive:true});
    return()=>{el.removeEventListener('pointerdown',down);el.removeEventListener('click',down);el.removeEventListener('pointerup',up);el.removeEventListener('pointercancel',up);el.removeEventListener('mouseleave',up);};
  }
  // Test controls: pointerdown-only + debounce
  const lastPress=new WeakMap();
  function onPressPointer(el,fn,db=200){
    function down(e){
      e.preventDefault();
      const t=now(), last=lastPress.get(el)||0;
      if(t-last<db) return;
      lastPress.set(el,t);
      el.classList.add('active'); fn(e);
    }
    const up=()=>el.classList.remove('active');
    el.addEventListener('pointerdown',down,{passive:false});
    el.addEventListener('pointerup',up,{passive:true});
    el.addEventListener('pointercancel',up,{passive:true});
    el.addEventListener('mouseleave',up,{passive:true});
    return()=>{el.removeEventListener('pointerdown',down);el.removeEventListener('pointerup',up);el.removeEventListener('pointercancel',up);el.removeEventListener('mouseleave',up);};
  }

  const storeKey="flyingm_imsafe_baseline_v2";
  const loadBaseline=()=>{try{return JSON.parse(localStorage.getItem(storeKey)||"[]");}catch{return[];}};
  const saveBaseline=s=>localStorage.setItem(storeKey,JSON.stringify(s||[]));

  // Refs
  const startBtn=$("#startBtn"), addBaselineBtn=$("#addBaselineBtn"), addBaselineBtn2=$("#addBaselineBtn2");
  const resetBaselineBtn=$("#resetBaselineBtn"), exportBtn=$("#exportBtn");
  const testCard=$("#testCard"), stepName=$("#stepName"), countdown=$("#countdown"), progressBar=$("#progressBar");
  const srtPane=$("#srtPane"), srtTarget=$("#srtTarget");
  const stroopPane=$("#stroopPane"), stroopWord=$("#stroopWord"), btnMatch=$("#btnMatch"), btnMismatch=$("#btnMismatch");
  const nbackPane=$("#nbackPane"), nbackDigit=$("#nbackDigit"), btnTarget=$("#btnTarget"), btnNotTarget=$("#btnNotTarget"), twoBackButtons=$("#twoBackButtons"), groupLabel=$("#groupLabel");
  const resultCard=$("#resultCard"), lightDot=$("#lightDot"), lightLabel=$("#lightLabel"), readinessPct=$("#readinessPct"), driverText=$("#driverText"), guidanceText=$("#guidanceText"), metricToday=$("#metricToday"), metricBase=$("#metricBase"), againBtn=$("#againBtn");
  const baselineCard=$("#baselineCard"), baselineList=$("#baselineList"), deleteBaselineBtn=$("#deleteBaselineBtn"), closeBaselineBtn=$("#closeBaselineBtn");

  let baselineSessions=loadBaseline();
  let sessionResult=null;

  function show(el){el.classList.remove("hide");}
  function hide(el){el.classList.add("hide");}
  function setProgress(p){progressBar.style.width=(p*100).toFixed(1)+"%";}

  [startBtn,addBaselineBtn,addBaselineBtn2,resetBaselineBtn,exportBtn,againBtn,deleteBaselineBtn,closeBaselineBtn].forEach(b=>b&&onTap(b,()=>{}));

  const DUR={warmup:5,srt:30,stroop:45,nbackGroups:5};
  const BASELINE_MIN=3;
  let abortFlag=false;

  async function runTest(){
    abortFlag=false; sessionResult=null; addBaselineBtn.disabled=true; addBaselineBtn2.disabled=true;
    hide(resultCard); hide(baselineCard); show(testCard);

    await sectionTimer("Warm-up",DUR.warmup,(t,p)=>{countdown.textContent=Math.ceil(t)+"s";setProgress(p);srtTarget.textContent="WAIT";srtTarget.className="tapTarget ready";show(srtPane);hide(stroopPane);hide(nbackPane);});
    const srt=await runSRT(DUR.srt); if(abortFlag) return;
    const stro=await runStroop(DUR.stroop); if(abortFlag) return;
    const nb=await runTwoBack(DUR.nbackGroups); if(abortFlag) return;
    sessionResult=computeScoring(srt,stro,nb,baselineSessions);
    renderResults(sessionResult,srt,stro,nb,baselineSessions);
  }

  function sectionTimer(name,sec,tick){
    stepName.textContent=name; const t0=now(), total=sec*1000;
    return new Promise(res=>{function frame(){const t=now()-t0; if(abortFlag) return res(); const rem=Math.max(0,total-t); const p=clamp(t/total,0,1); tick(rem/1000,p); if(t<total) requestAnimationFrame(frame); else res();} requestAnimationFrame(frame);});
  }

  // SRT
  async function runSRT(sec){
    show(srtPane); hide(stroopPane); hide(nbackPane);
    let rts=[], falseStarts=0, lapses=0, waiting=true, goTime=0; const endAt=now()+sec*1000;

    function scheduleNext(){
      waiting=true; const delay=1200+Math.random()*1300;
      srtTarget.textContent="WAIT"; srtTarget.className="tapTarget ready";
      setTimeout(()=>{ if(now()>endAt) return; srtTarget.textContent="TAP"; srtTarget.className="tapTarget go"; waiting=false; goTime=now(); },delay);
    }
    const off=onPressPointer(srtTarget,()=>{
      if(now()>endAt) return;
      if(waiting){ falseStarts++; }
      else{
        const rt=now()-goTime;
        if(rt>500) lapses++;
        else if(rt>=100) rts.push(rt);
        scheduleNext();
      }
    });
    scheduleNext();
    await sectionTimer("Reaction",sec,(tleft,p)=>{countdown.textContent=Math.ceil(tleft)+"s"; setProgress((DUR.warmup+(DUR.srt-tleft))/(DUR.warmup+DUR.srt+DUR.stroop+15));});
    off();
    const medianRT=rts.length?rts.slice().sort((a,b)=>a-b)[Math.floor(rts.length/2)]:999;
    return {medianRT,lapses,falseStarts,n:rts.length};
  }

  // Stroop (balanced; 400 ms ISI; no immediate repeats)
  async function runStroop(sec){
    show(stroopPane); hide(srtPane); hide(nbackPane);
    const names=["RED","GREEN","BLUE","YELLOW"];
    const colors={RED:"#ff4d4d",GREEN:"#18d96e",BLUE:"#4da3ff",YELLOW:"#ffd633"};
    let trials=[], tStim=0, awaiting=false, prevWord=null, prevColor=null;
    const endAt=now()+sec*1000, gap=400;

    function nextPair(){
      const wantCong = Math.random()<0.5;
      let word; do{word=names[Math.floor(Math.random()*names.length)];}while(word===prevWord);
      let colorName;
      if(wantCong){
        colorName=word;
        if(colorName===prevColor){ const others=names.filter(n=>n!==word && n!==prevWord); word=others[Math.floor(Math.random()*others.length)]; colorName=word; }
      }else{
        do{ colorName=names[Math.floor(Math.random()*names.length)]; } while(colorName===word || colorName===prevColor);
      }
      prevWord=word; prevColor=colorName;
      return {word,colorName,congruent:(word===colorName)};
    }

    let current=null;
    function showTrial(){
      const p=nextPair();
      current=p; stroopWord.textContent=p.word; stroopWord.style.color=colors[p.colorName]; stroopWord.style.visibility="visible";
      tStim=now(); awaiting=true; btnMatch.classList.remove('active'); btnMismatch.classList.remove('active');
    }
    function queueNext(){ stroopWord.style.visibility="hidden"; setTimeout(()=>{ if(now()<endAt) showTrial(); },gap); }
    function respond(which){
      if(!awaiting) return; awaiting=false;
      const rt=now()-tStim;
      const correct=(current.word===current.colorName && which==="MATCH") || (current.word!==current.colorName && which==="MISMATCH");
      trials.push({rt,correct,congruent:current.congruent});
      (which==="MATCH"?btnMatch:btnMismatch).classList.add('active');
      queueNext();
    }

    const offM=onPressPointer(btnMatch,()=>respond("MATCH"));
    const offMM=onPressPointer(btnMismatch,()=>respond("MISMATCH"));
    function key(e){const k=e.key?.toLowerCase(); if(k==='f') respond("MATCH"); if(k==='j') respond("MISMATCH");}
    window.addEventListener('keydown',key);

    showTrial();
    await sectionTimer("Color-Word",sec,(tleft,p)=>{countdown.textContent=Math.ceil(tleft)+"s"; const prog=(DUR.warmup+DUR.srt+(DUR.stroop-tleft))/(DUR.warmup+DUR.srt+DUR.stroop+15); setProgress(prog);});
    offM(); offMM(); window.removeEventListener('keydown',key);

    const corrects=trials.filter(t=>t.correct);
    const acc=trials.length?(corrects.length/trials.length)*100:0;
    const cong=trials.filter(t=>t.congruent && t.correct).map(t=>t.rt);
    const incong=trials.filter(t=>!t.congruent && t.correct).map(t=>t.rt);
    const rtCon=cong.length?mean(cong):NaN, rtIncon=incong.length?mean(incong):NaN;
    const raw=(isFinite(rtIncon)&&isFinite(rtCon))?(rtIncon-rtCon):NaN;
    const congruencyCost=isFinite(raw)?Math.max(0,raw):NaN;
    const meanRTCorrect=corrects.length?mean(corrects.map(t=>t.rt)):NaN;
    const stroopScore=acc;
    return {acc,meanRTCorrect,congruencyCost,n:trials.length,stroopScore, nCong:cong.length, nIncong:incong.length};
  }

  // 2-back (A and B flash; C appears ONCE and PERSISTS with buttons active)
  async function runTwoBack(groups){
    show(nbackPane); hide(srtPane); hide(stroopPane);
    let group=1, hits=0, fas=0, miss=0, hitRTs=[];
    const VIS=250, GAP=100; let tStim=0; twoBackButtons.style.visibility="hidden";

    function setDigit(d,vis){ nbackDigit.textContent=String(d); nbackDigit.style.visibility=vis?"visible":"hidden"; }
    function rDigit(except){ let d; do{ d=Math.floor(1+Math.random()*9); }while(d===except); return d; }

    function doGroup(){
      if(group>groups) return Promise.resolve();
      groupLabel.textContent=`Group ${group}`; twoBackButtons.style.visibility="hidden";
      const a=rDigit(null), b=rDigit(null), target=Math.random()<0.5, c=target?a:rDigit(a);

      return new Promise(res=>{
        // Play A then B (flash), then SHOW C and KEEP it visible while awaiting response
        function showA(){
          setDigit(a,true);
          setTimeout(()=>{ setDigit(a,false); setTimeout(showB,GAP); },VIS);
        }
        function showB(){
          setDigit(b,true);
          setTimeout(()=>{ setDigit(b,false); setTimeout(showC,GAP); },VIS);
        }
        function showC(){
          setDigit(c,true);
          twoBackButtons.style.visibility="visible";
          awaiting=true;
          tStim=now(); // RT starts when C appears and stays visible
        }

        let awaiting=false;
        function evalResp(isTarget){
          if(!awaiting) return;
          awaiting=false;
          const rt=now()-tStim, correctTarget=(c===a);
          if(isTarget){ if(correctTarget){ hits++; if(rt>=100 && rt<=3000) hitRTs.push(rt); } else { fas++; } }
          else { if(correctTarget){ miss++; } }
          setDigit(c,false); twoBackButtons.style.visibility="hidden";
          offT(); offNT(); offKey(); group++; res();
        }
        const offT=onPressPointer(btnTarget,()=>evalResp(true));
        const offNT=onPressPointer(btnNotTarget,()=>evalResp(false));
        function key(e){ if(e.code==='Space'){e.preventDefault();evalResp(true);} if(e.key && e.key.toLowerCase()==='n'){e.preventDefault();evalResp(false);} }
        function offKey(){ window.removeEventListener('keydown',key); }
        window.addEventListener('keydown',key);

        // kick off A
        showA();
      }).then(()=>doGroup());
    }

    await doGroup();

    const total=groups, targets=Math.max(1, hits+miss), nonTargets=Math.max(1, total-(hits+miss));
    const hitRate=(hits/targets)*100, faRate=(fas/nonTargets)*100;
    const dprime=dPrimeApprox(hitRate/100, faRate/100);
    const meanHitRT=hitRTs.length?mean(hitRTs):NaN;
    return {hitRate,faRate,dprime,meanHitRT,counts:{hits,fas,miss},groups:total};
  }

  function dPrimeApprox(H,F){
    const eps=1e-4; H=clamp(H,eps,1-eps); F=clamp(F,eps,1-eps);
    function invNorm(p){
      const a=[-39.6968302866538,220.946098424521,-275.928510446969,138.357751867269,-30.6647980661472,2.50662827745924];
      const b=[-54.4760987982241,161.585836858041,-155.698979859887,66.8013118877197,-13.2806815528857];
      const c=[-0.00778489400243029,-0.322396458041136,-2.40075827716184,-2.54973253934373,4.37466414146497,2.93816398269878];
      const d=[0.00778469570904146,0.32246712907004,2.445134137143,3.75440866190742];
      const pl=0.02425, ph=1-pl; let q,r;
      if(p<pl){ q=Math.sqrt(-2*Math.log(p)); return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/(((((d[0]*q+d[1])*q+d[2])*q+d[3])*q)+1); }
      if(p>ph){ q=Math.sqrt(-2*Math.log(1-p)); return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/(((((d[0]*q+d[1])*q+d[2])*q+d[3])*q)+1); }
      q=p-0.5; r=q*q;
      return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q/((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
    }
    return invNorm(H)-invNorm(F);
  }

  function computeScoring(srt,stro,nb,baseline){
    const today={ srt_median:srt.medianRT, srt_lapses:srt.lapses, srt_false:srt.falseStarts,
      stro_acc:stro.acc, stro_mean_rt:stro.meanRTCorrect, stro_cost:stro.congruencyCost, stro_score:stro.stroopScore,
      nb_hit:nb.hitRate, nb_fa:nb.faRate, nb_d:nb.dprime, nb_hit_rt:nb.meanHitRT };

    const base=computeBaselineStats(baseline);
    function zLower(key){ const m=base.mean[key], s=base.sd[key]; if(!isFinite(m)||s===0||!isFinite(today[key])) return NaN; return (today[key]-m)/s; }
    function zHigher(key){ const m=base.mean[key], s=base.sd[key]; if(!isFinite(m)||s===0||!isFinite(today[key])) return NaN; return (m-today[key])/s; }
    const z={ speed_median:zLower("srt_median"), speed_lapses:zLower("srt_lapses"), speed_false:zLower("srt_false"),
      stro_cost:zLower("stro_cost"), stro_acc:zHigher("stro_acc"), stro_rt:zLower("stro_mean_rt"),
      nb_d:zLower("nb_d"), nb_hit_rt:zLower("nb_hit_rt"), nb_fa:zLower("nb_fa") };
    function comp(keys){ const vals=keys.map(k=>z[k]).filter(Number.isFinite); if(!vals.length) return NaN; const srt=vals.slice().sort((a,b)=>a-b); const trim=Math.max(0,Math.floor(srt.length*0.1)); return mean(srt.slice(trim, srt.length-trim||undefined)); }
    const zSpeed=comp(["speed_median","speed_lapses","speed_false"]);
    const zStroop=comp(["stro_cost","stro_acc","stro_rt"]);
    const zNback=comp(["nb_d","nb_hit_rt","nb_fa"]);
    const maxZ=Math.max(zSpeed||0,zStroop||0,zNback||0);
    let readiness=Math.round(100-clamp(12*maxZ,0,60));

    const hasBaseline=baseline.length>=BASELINE_MIN;
    let light="amber", label="Caution", guidance="Delay 15–30 minutes, hydrate/snack, then re-test. Consider a safety pilot or deferring non-essential legs.";
    if((maxZ<1.0)&&readiness>=85){ light="green"; label="Fit"; guidance="Proceed if all other IM SAFE items are satisfied."; }
    else if(maxZ>=2.0 || readiness<70){ light="red"; label="No-Go"; guidance="Do not act as PIC. Address sleep/stress/alcohol/meds and re-test later."; }
    if(srt.lapses>=2 || (isFinite(stro.acc)&&stro.acc<85)){ light="red"; label="No-Go"; guidance="Do not act as PIC. Significant attention/alertness degradation detected."; readiness=Math.min(readiness,69); }

    // T-score (baseline mean 50, SD 10)
    let stroopTScore=NaN, stroopMessage="—";
    if(isFinite(today.stro_score)&&isFinite(base.mean.stro_score)&&base.sd.stro_score>0){
      const zSt=(today.stro_score-base.mean.stro_score)/base.sd.stro_score;
      stroopTScore=50+10*zSt;
      const drop=(50-stroopTScore)/50;
      if(drop<=0.10) stroopMessage="No significant decline in executive function compared to baseline score.";
      else if(drop>0.10 && drop<=0.15000) stroopMessage="Small executive function deficit detected compared to baseline score.";
      else if(drop>0.15001 && drop<=0.20) stroopMessage="Significant executive function deficit detected compared to baseline score. Reconsider performing a flight.";
      else if(drop>0.20) stroopMessage="Substantial executive function deficit detected compared to baseline score. You are strongly encouraged to scrub your flight.";
    } else {
      stroopMessage="Collect at least 3 baseline sessions to enable T-score comparison.";
    }

    if(!hasBaseline){ light="amber"; label="Baseline required"; guidance="Establish your personal baseline (≥3 sessions on good days). Until then, do not use this tool for go/no-go decisions."; }

    const drivers=[];
    if(Number.isFinite(zSpeed)&&zSpeed>=1) drivers.push("slower reaction & vigilance");
    if(Number.isFinite(zStroop)&&zStroop>=1) drivers.push("reduced attention control");
    if(Number.isFinite(zNback)&&zNback>=1) drivers.push("weaker working memory");
    const driver=!hasBaseline? "Baseline not established." : (drivers.length?("Top driver: "+drivers.join(" + ")):"Near baseline across domains.");

    const nbackNote = (DUR.nbackGroups<=5) ? "Note: 2-back d′ is based on 5 trials and may be unstable; consider optional 10–20 groups for research-grade stability." : "";

    return {today,baseStats:base,z:{speed:zSpeed,stroop:zStroop,nback:zNback,max:maxZ},
            readiness,light,label,guidance,driver,hasBaseline,stroopTScore,stroopMessage,nbackNote, stroopCounts:{cong:0,incong:0}};
  }

  function computeBaselineStats(b){
    const keys=["srt_median","srt_lapses","srt_false","stro_acc","stro_mean_rt","stro_cost","stro_score","nb_hit","nb_fa","nb_d","nb_hit_rt"];
    const meanObj={}, sdObj={}; keys.forEach(k=>{const arr=b.map(s=>s[k]).filter(x=>Number.isFinite(x)); meanObj[k]=arr.length?mean(arr):NaN; sdObj[k]=arr.length>1?sd(arr):0;});
    return {mean:meanObj, sd:sdObj, n:b.length};
  }

  function renderResults(res,srt,stro,nb){
    hide(testCard); show(resultCard);
    readinessPct.textContent=res.hasBaseline? (res.readiness+"%"):"—";
    lightDot.className="dot "+(res.hasBaseline?(res.light==="green"?"green":res.light==="red"?"red":"amber"):"amber");
    lightLabel.textContent=res.hasBaseline? res.label:"Baseline required";
    driverText.textContent=res.driver;
    guidanceText.textContent=res.guidance;

    addBaselineBtn.disabled=false; addBaselineBtn2.disabled=false;

    const totalPresses=srt.falseStarts+srt.n, fsRate=totalPresses?(100*srt.falseStarts/totalPresses):0;

    metricToday.innerHTML=[
      `Reaction median: <b>${fmt(srt.medianRT)} ms</b>`,
      `Lapses (&gt;500 ms): <b>${srt.lapses}</b>`,
      `False starts: <b>${srt.falseStarts}</b>`,
      `<span class="muted">Diagnostics — SRT trials: <b>${srt.n}</b>; presses: <b>${totalPresses}</b>; false-start rate: <b>${fmt(fsRate)}%</b></span>`,
      `Stroop accuracy: <b>${fmt(stro.acc)}%</b>`,
      `Stroop mean RT: <b>${fmt(stro.meanRTCorrect)} ms</b>`,
      `Stroop cost: <b>${isFinite(stro.congruencyCost)?fmt(stro.congruencyCost):"—"} ms</b>`,
      `2-back d′: <b>${isFinite(nb.dprime)?fmt(nb.dprime):"—"}</b>`,
      `2-back hits / FA / miss: <b>${nb.counts.hits}/${nb.counts.fas}/${nb.counts.miss}</b>`,
      res.nbackNote? `<span class="muted">${res.nbackNote}</span>` : ``
    ].map(x=>`<div>${x}</div>`).join("");

    const b=res.baseStats;
    function baseLine(label,key,unit=""){const m=b.mean[key], s=b.sd[key]; return `<div>${label}: <b>${isFinite(m)?fmt(m):"—"}${unit}</b> <span class="muted">± ${isFinite(s)?fmt(s):"—"}</span></div>`;}
    metricBase.innerHTML=[
      baseLine("Reaction median","srt_median"," ms"),
      baseLine("Lapses","srt_lapses"),
      baseLine("False starts","srt_false"),
      baseLine("Stroop accuracy","stro_acc","%"),
      baseLine("Stroop mean RT","stro_mean_rt"," ms"),
      baseLine("Stroop cost","stro_cost"," ms"),
      baseLine("Stroop score (acc)","stro_score",""),
      baseLine("2-back d′","nb_d",""),
    ].join("");

    resultCard.dataset.payload=JSON.stringify({srt,stro,nb,res});
  }

  onTap(startBtn,runTest); onTap(againBtn,runTest);

  function addCurrentToBaseline(){
    const payload=resultCard.dataset.payload?JSON.parse(resultCard.dataset.payload):null; if(!payload) return;
    const {srt,stro,nb}=payload;
    const today={ srt_median:srt.medianRT, srt_lapses:srt.lapses, srt_false:srt.falseStarts,
      stro_acc:stro.acc, stro_mean_rt:stro.meanRTCorrect, stro_cost:stro.congruencyCost, stro_score:stro.stroopScore,
      nb_hit:nb.hitRate, nb_fa:nb.faRate, nb_d:nb.dprime, nb_hit_rt:nb.meanHitRT };
    baselineSessions.push(today); saveBaseline(baselineSessions);
    alert("Added to baseline. Collect at least 3 baseline sessions on good days to enable assessment.");
  }
  onTap(addBaselineBtn,addCurrentToBaseline); onTap(addBaselineBtn2,addCurrentToBaseline);

  onTap(resetBaselineBtn,()=>{updateBaselineList(); hide(resultCard); hide(testCard); show(baselineCard);});
  onTap(closeBaselineBtn,()=>hide(baselineCard));
  onTap(deleteBaselineBtn,()=>{ if(confirm("Delete ALL baseline sessions on this device?")){ baselineSessions=[]; saveBaseline(baselineSessions); updateBaselineList(); } });

  onTap(exportBtn,()=>{
    const payload=resultCard.dataset.payload?JSON.parse(resultCard.dataset.payload):null;
    const bcount=baselineSessions.length; const when=new Date().toLocaleString();
    let html=`<html><head><title>IM SAFE — Two-Minute Drill Summary</title>
      <style>body{font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:24px;color:#111}
      h1{font-size:20px;margin:0 0 6px} h2{font-size:16px;margin:18px 0 6px}
      .muted{color:#555}.grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}.box{border:1px solid #ddd;border-radius:8px;padding:12px}
      .mono{font-family:ui-monospace,Menlo,Monaco,Consolas}</style></head><body>
      <h1>IM SAFE — Two-Minute Drill (Summary)</h1>
      <div class="muted">Generated: ${when} • Baseline sessions on this device: ${bcount}</div>`;
    if(!payload){ html+=`<p>No recent test run to export.</p></body></html>`; const w=window.open("","_blank"); w.document.write(html); w.print(); return; }
    const {srt,stro,nb,res}=payload; const totalPresses=srt.falseStarts+srt.n; const fsRate=totalPresses?(100*srt.falseStarts/totalPresses):0;
    html+=`
      <h2>Overall</h2>
      <div class="box">
        <div><b>Assessment:</b> ${res.hasBaseline?res.label:"Baseline required"} ${res.hasBaseline?("• Readiness "+res.readiness+"%"):""}</div>
        <div><b>Guidance:</b> ${res.guidance}</div>
        <div><b>Driver:</b> ${res.driver}</div>
      </div>
      <div class="grid" style="margin-top:10px">
        <div class="box">
          <h2>Reaction</h2>
          <div>Median RT: <b>${fmt(srt.medianRT)} ms</b></div>
          <div>Lapses (&gt;500 ms): <b>${srt.lapses}</b></div>
          <div>False starts: <b>${srt.falseStarts}</b></div>
          <div class="muted">Diagnostics — trials: <b>${srt.n}</b>; presses: <b>${totalPresses}</b>; false-start rate: <b>${fmt(fsRate)}%</b></div>
        </div>
        <div class="box">
          <h2>Stroop (Executive Function)</h2>
          <div>Accuracy: <b>${fmt(stro.acc)}%</b></div>
          <div>Mean RT (correct): <b>${fmt(stro.meanRTCorrect)} ms</b></div>
          <div>Cost (incong − cong): <b>${isFinite(stro.congruencyCost)?fmt(stro.congruencyCost):"—"} ms</b></div>
          <div>T-Score vs baseline: <b>${isFinite(res.stroopTScore)?fmt(res.stroopTScore):"—"}</b></div>
          <div><i>${res.stroopMessage}</i></div>
        </div>
      </div>
      <div class="box" style="margin-top:10px">
        <h2>2-back (Working Memory)</h2>
        <div>d′: <b>${isFinite(nb.dprime)?fmt(nb.dprime):"—"}</b></div>
        <div>Hits / False Alarms / Misses: <b>${nb.counts.hits}/${nb.counts.fas}/${nb.counts.miss}</b> (${nb.groups} groups)</div>
        ${res.nbackNote?`<div class="muted">${res.nbackNote}</div>`:""}
      </div>
      <h2>Baseline (mean ± SD)</h2>
      <div class="box mono">
        Reaction median: ${fmt(res.baseStats.mean.srt_median)} ms ± ${fmt(res.baseStats.sd.srt_median)}<br/>
        Lapses: ${fmt(res.baseStats.mean.srt_lapses)} ± ${fmt(res.baseStats.sd.srt_lapses)}<br/>
        False starts: ${fmt(res.baseStats.mean.srt_false)} ± ${fmt(res.baseStats.sd.srt_false)}<br/>
        Stroop accuracy: ${fmt(res.baseStats.mean.stro_acc)}% ± ${fmt(res.baseStats.sd.stro_acc)}<br/>
        Stroop mean RT: ${fmt(res.baseStats.mean.stro_mean_rt)} ms ± ${fmt(res.baseStats.sd.stro_mean_rt)}<br/>
        Stroop cost: ${fmt(res.baseStats.mean.stro_cost)} ms ± ${fmt(res.baseStats.sd.stro_cost)}<br/>
        Stroop score (acc): ${fmt(res.baseStats.mean.stro_score)} ± ${fmt(res.baseStats.sd.stro_score)}<br/>
        2-back d′: ${fmt(res.baseStats.mean.nb_d)} ± ${fmt(res.baseStats.sd.nb_d)}
      </div></body></html>`;
    const w=window.open("","_blank"); w.document.open(); w.document.write(html); w.document.close(); w.focus(); w.print();
  });

  function updateBaselineList(){
    const b=baselineSessions;
    if(!b.length){ baselineList.textContent="No baseline yet."; return; }
    baselineList.innerHTML=b.map((s,i)=>`<div class="chip">#${i+1} • medRT ${fmt(s.srt_median)} ms • lapses ${s.srt_lapses} • Stroop acc ${fmt(s.stro_acc)}% • 2-back d′ ${fmt(s.nb_d)}</div>`).join("<br/>");
  }
  updateBaselineList();

  window.addEventListener("beforeunload",e=>{ if(!testCard.classList.contains("hide")){e.preventDefault(); e.returnValue="";} });
})();
</script>
</body>
</html>
